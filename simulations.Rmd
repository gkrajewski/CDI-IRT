---
title: "Simulations"
author: "Piotr Kr√≥l"
date: "02 08 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
```

Content:

* Fixed-length CAT simulations with random selection of items
* Fixed-length CAT simulations with MI item selection criteria
* Early-stopping CAT simulations with needed SE = 0.1
* CAT simulations with stop when SE = 0.15 or some maximum number of items is reached
* Start item by age and gender vs. not

```{r warning=FALSE, message=FALSE}
library(mirt)
library(mirtCAT)
library(parallel)
library(plyr)
library(beepr)
library(ggpubr)
```
```{r eval=F}
responses_demo <- read.csv("Data/responses_demo.csv", encoding = "UTF-8")
responses <- as.matrix(responses_demo[,5:ncol(responses_demo)])
```

```{r include=F}
load("Data/simulations.RData")
```

```{r}
mod
```
Prepare for simulations:

```{r eval=F}
fscores <- fscores(mod, method = "MAP") #Obtain full scores
params <- as.data.frame(coef(mod, simplify = TRUE)$items)[1:2] #Prepare params
mo <- generate.mirt_object(params, '2PL') #Prepare mirt object
```
Since fscores function failed to converge for three subjects I remove them:

```{r eval=F}
subjects_to_remove <- c(783, 1156, 1648)
fscores <- fscores[-subjects_to_remove]
responses <- responses[-subjects_to_remove, ]
```

Set tests lengths for CAT simulations:

```{r}
lengths <- c(5, 10, 15, 25, 35, 50, 100)
```

## Fixed-length CAT simulations with random selection of items

```{r eval=F}
results_fixed_length_random <- data.frame(length = NA, cor = NA, avgSE = NA, rel = NA, unused = NA)

for (n in lengths){
  
  #Make simulation
  cl <- makeCluster(detectCores())
  sim_results <- mirtCAT(mo = mo, method = "MAP", criteria = "random", start_item = "random", local_pattern = responses, cl = cl, design = list( min_items = n, max_items = n))
  
  #Obtain thetas
  thetas <- laply(sim_results, function(x) x$thetas)
  
  #Get correlation of thetas with full scores
  cor <- round(cor(thetas, as.numeric(fscores)), 3)
  
  #Get average SE
  avgSE <- round(mean(laply(sim_results, function(x) x$SE_thetas)),3)
  
  #Get reliability
  rel <- round(1 - avgSE**2, 3)
  
  #Get number of unused items (fixed length)
  items_answered <- laply(sim_results, function(x) x$items_answered)
  unused <- nrow(params) - length(unique(as.vector(items_answered)))
  
  #Update data frame with results
  results_fixed_length_random <- rbind(results_fixed_length_random, c(n, cor, avgSE, rel, unused))
  
}

results_fixed_length_random <- na.omit(results_fixed_length_random)
beep(sound=8)
```

```{r}
results_fixed_length_random
```

## Fixed-length CAT simulations with MI item selection criteria

```{r eval=F}
results_fixed_length_MI <- data.frame(length = NA, cor = NA, avgSE = NA, rel = NA, unused = NA)

for (n in lengths){
  
  #Make simulation
  cl <- makeCluster(detectCores())
  sim_results <- mirtCAT(mo = mo, method = "MAP", criteria = "MI", start_item = "MI", local_pattern = responses, cl = cl, design = list(min_items = n, max_items = n))
  
  #Obtain thetas
  thetas <- laply(sim_results, function(x) x$thetas)
  
  #Get correlation of thetas with full scores
  cor <- round(cor(thetas, as.numeric(fscores)), 3)
  
  #Get average SE
  avgSE <- round(mean(laply(sim_results, function(x) x$SE_thetas)),3)
  
  #Get reliability
  rel <- round(1 - avgSE**2, 3)
  
  #Get number of unused items (fixed length)
  items_answered <- laply(sim_results, function(x) x$items_answered)
  unused <- nrow(params) - length(unique(as.vector(items_answered)))
  
  #Update data frame with results
  results_fixed_length_MI <- rbind(results_fixed_length_MI, c(n, cor, avgSE, rel, unused))
  
}

results_fixed_length_MI <- na.omit(results_fixed_length_MI)
beep(sound=8)
```

```{r}
results_fixed_length_MI
```

## Early-stopping CAT simulations with needed SE = 0.1

```{r eval=F}
results_SE1 <- data.frame(avglength = NA, cor = NA, avgSE = NA, rel = NA, unused = NA)
  
#Make simulation
cl <- makeCluster(detectCores())
sim_results <- mirtCAT(mo = mo, method = "MAP", criteria = "MI", start_item = "MI", local_pattern = responses, cl = cl, design = list(min_SEM = 0.1))

#Obtain average test length
tests_lengths <- laply(sim_results, function(x) length(x$items_answered))
avglength <- round(mean(tests_lengths), 1)

#Obtain thetas
thetas <- laply(sim_results, function(x) x$thetas)

#Get correlation of thetas with full scores
cor <- round(cor(thetas, as.numeric(fscores)), 3)

#Get average SE
avgSE <- round(mean(laply(sim_results, function(x) x$SE_thetas)),3)

#Get reliability
rel <- round(1 - avgSE**2, 3)

#Get number of unused items
raw_responses <- laply(sim_results, function(x) x$raw_responses)
items_used <- length(which(apply(raw_responses, 2, function(x) any(!is.na(x)))))
unused <- nrow(params) - items_used

#Update data frame with results
results_SE1 <- rbind(results_SE1, c(avglength, cor, avgSE, rel, unused))

#Prepare cuts
cuts <- cut(tests_lengths, breaks = c(0, 5, 10, 15, 25, 35, 50, 75, 100, 200, 669, 670), labels = c("1 - 5", "6 - 10", "11 - 15", "16 - 25", "26 - 35", "36 - 50", "51 - 75", "76 - 100", "101 - 200", "201 - 669", "670"), dig.lab = 0)

#Plot distribution of tests lengths
plot_SE1 <- ggplot(data.frame(table(cuts)), aes(x = cuts, y = Freq)) +
  xlab("Number of items in the test") +
  ylab("Number of tests") +
  geom_bar(stat = "identity") +
  ggtitle("Tests lengths for SE = 0.1 stop criterion") +
  geom_text(aes(label = Freq), vjust = -0.3) + 
  theme_pubclean() 
  
results_SE1 <- na.omit(results_SE1)
beep(sound=8)
```

```{r}
results_SE1
```

```{r}
plot_SE1
```

## CAT simulations with stop when SE = 0.15 or some maximum number of items is reached

```{r eval=F}
results_SE15_max <- data.frame(maxlength = NA, avglength = NA, cor = NA, avgSE = NA, rel = NA, unused = NA)

for (n in lengths){
  
  #Make simulation
  cl <- makeCluster(detectCores())
  sim_results <- mirtCAT(mo = mo, method = "MAP", criteria = "MI", start_item = "MI", local_pattern = responses, cl = cl, design = list(min_SEM = 0.15, max_items = n))
  
  #Obtain average test length
  avglength <- round(mean(laply(sim_results, function(x) length(x$items_answered))), 1)
  
  #Obtain thetas
  thetas <- laply(sim_results, function(x) x$thetas)
  
  #Get correlation of thetas with full scores
  cor <- round(cor(thetas, as.numeric(fscores)), 3)
  
  #Get average SE
  avgSE <- round(mean(laply(sim_results, function(x) x$SE_thetas)),3)
  
  #Get reliability
  rel <- round(1 - avgSE**2, 3)
  
  #Get number of unused items
  raw_responses <- laply(sim_results, function(x) x$raw_responses)
  items_used <- length(which(apply(raw_responses, 2, function(x) any(!is.na(x)))))
  unused <- nrow(params) - items_used
  
  #Update data frame with results
  results_SE15_max <- rbind(results_SE15_max, c(n, avglength, cor, avgSE, rel, unused))
  
}

results_SE15_max <- na.omit(results_SE15_max)
beep(sound=8)
```

```{r}
results_SE15_max
```

## Start item by age and gender vs. not

Prepare full scores with demographic variables:

```{r eval=F}
fscores_demo <- cbind(responses_demo[-subjects_to_remove, c("days", "months", "gender")], fscores)
fscores_demo$weeks <- ceiling(fscores_demo$days / 7)
```

### Start item by months and gender

Get start theta for each subject (by months and gender):

```{r}
fscores_aggr <- aggregate(fscores ~ months + gender, data = fscores_demo, mean)
age_unit <- colnames(fscores_aggr)[1]
start_thetas <- as.matrix(
    mapply(
      function(age, gender){
        return(fscores_aggr[fscores_aggr[[age_unit]] == age & fscores_aggr$gender == gender, "fscores"])
      },
      fscores_demo[[age_unit]],
      fscores_demo$gender
    )
  )
```

Make simulation with start thetas given:

```{r eval=F}
#Make simulation
cl <- makeCluster(detectCores())
sim_results <- mirtCAT(mo = mo, method = "MAP", criteria = "MI", start_item = "MI", local_pattern = responses, cl = cl, design = list(min_SEM = 0.15, max_items = 50, min_items = 25, thetas.start = start_thetas))

#Obtain average test length
avglength <- round(mean(laply(sim_results, function(x) length(x$items_answered))), 1)

#Obtain thetas
thetas <- laply(sim_results, function(x) x$thetas)

#Get correlation of thetas with full scores
cor <- round(cor(thetas, as.numeric(fscores)), 3)

#Get average SE
avgSE <- round(mean(laply(sim_results, function(x) x$SE_thetas)),3)

#Get reliability
rel <- 1 - avgSE**2
  
#Get number of unused items (fixed length)
raw_responses <- laply(sim_results, function(x) x$raw_responses)
items_used <- length(which(apply(raw_responses, 2, function(x) any(!is.na(x)))))
unused <- nrow(params) - items_used

#Create data frame with results
results_start_thetas <- data.frame(avglength = avglength, cor = cor, avgSE = avgSE, rel = rel, unused = unused)
  
beep(sound=8)
```

```{r}
results_start_thetas
```

### No start thetas given

Make simulation without start thetas:

```{r eval=F}
#Make simulation
cl <- makeCluster(detectCores())
sim_results <- mirtCAT(mo = mo, method = "MAP", criteria = "MI", start_item = "MI", local_pattern = responses, cl = cl, design = list(min_SEM = 0.15, max_items = 50, min_items = 25))

#Obtain average test length
avglength <- round(mean(laply(sim_results, function(x) length(x$items_answered))), 1)

#Obtain thetas
thetas <- laply(sim_results, function(x) x$thetas)

#Get correlation of thetas with full scores
cor <- round(cor(thetas, as.numeric(fscores)), 3)

#Get average SE
avgSE <- round(mean(laply(sim_results, function(x) x$SE_thetas)),3)

#Get reliability
rel <- 1 - avgSE**2
  
#Get number of unused items (fixed length)
raw_responses <- laply(sim_results, function(x) x$raw_responses)
items_used <- length(which(apply(raw_responses, 2, function(x) any(!is.na(x)))))
unused <- nrow(params) - items_used

#Create data frame with results
results <- data.frame(avglength = avglength, cor = cor, avgSE = avgSE, rel = rel, unused = unused)
  
beep(sound=8)
```

```{r}
results
```




